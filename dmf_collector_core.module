<?php

/**
 * @file
 * Anyrel Collector module functions.
 */

use DigitalMarketingFramework\Collector\Core\Registry\RegistryInterface as CollectorRegistryInterface;
use DigitalMarketingFramework\Core\Registry\RegistryCollectionInterface;
use Drupal\block_content\Plugin\Block\BlockContentBlock;
use Drupal\Core\Block\BlockPluginInterface;
use Drupal\Core\Entity\Display\EntityViewDisplayInterface;
use Drupal\Core\Entity\EntityInterface;
use Drupal\Core\Form\FormStateInterface;
use Drupal\dmf_collector_core\ContentModifier\ContentModifierFieldManager;
use Drupal\dmf_collector_core\Render\ContentModifierPreRender;
use Drupal\paragraphs\ParagraphInterface;

/**
 * Implements hook_entity_build_defaults_alter().
 *
 * Attaches a pre-render callback to entities that have content modifier fields.
 * The callback registers settings and adds data attributes during rendering.
 *
 * This hook runs BEFORE EntityViewBuilder sets up its #pre_render callbacks,
 * ensuring our callback is present when the Renderer processes the array.
 * Using hook_entity_view_alter() would be too late - it runs inside the
 * EntityViewBuilder's #pre_render, after the pre-render phase has passed.
 */
function dmf_collector_core_entity_build_defaults_alter(array &$build, EntityInterface $entity, string $view_mode): void {
  // Check if entity has any content modifier field.
  $hasPageField = $entity->hasField(ContentModifierFieldManager::FIELD_NAME_PAGE);
  $hasElementField = $entity->hasField(ContentModifierFieldManager::FIELD_NAME_ELEMENT);

  if (!$hasPageField && !$hasElementField) {
    return;
  }

  // Attach pre-render callback using trusted callback pattern.
  $build['#pre_render'][] = [ContentModifierPreRender::class, 'preRenderCallback'];
}

/**
 * Implements hook_page_bottom().
 *
 * Outputs the global DMF settings JSON block and attaches frontend scripts.
 * Uses a lazy builder to ensure settings are collected after all content
 * (including lazy-built blocks in regions) has been rendered.
 */
function dmf_collector_core_page_bottom(array &$page_bottom): void {
  // Only output on non-admin pages.
  if (\Drupal::service('router.admin_context')->isAdminRoute()) {
    return;
  }

  // Use a lazy builder so settings are collected after all blocks render.
  // This is necessary because Block Layout blocks use lazy builders and
  // are rendered after hook_page_bottom() normally runs.
  $page_bottom['dmf_settings'] = [
    '#lazy_builder' => [
      'dmf_collector_core.settings_lazy_builder:renderSettings',
      [],
    ],
    '#create_placeholder' => TRUE,
  ];
}

/**
 * Implements hook_form_BASE_FORM_ID_alter() for node_form.
 *
 * Moves the page content modifier field to the sidebar (advanced region)
 * as a collapsible "Content Personalization" section.
 */
function dmf_collector_core_form_node_form_alter(array &$form, FormStateInterface $form_state, string $form_id): void {
  $fieldName = ContentModifierFieldManager::FIELD_NAME_PAGE;

  // Check if the page content modifier field exists on this form.
  if (!isset($form[$fieldName])) {
    return;
  }

  // Create a details wrapper for the sidebar.
  $form['dmf_content_personalization'] = [
    '#type' => 'details',
    '#title' => t('Content Personalization'),
    '#group' => 'advanced',
    '#weight' => 90,
    '#optional' => TRUE,
    '#open' => FALSE,
    '#attributes' => [
      'class' => ['node-form-dmf-content-personalization'],
    ],
  ];

  // Move the field into the container using #group.
  $form[$fieldName]['#group'] = 'dmf_content_personalization';
}

/**
 * Implements hook_ENTITY_TYPE_view() for paragraph entities.
 *
 * Handles rendering of the "Anyrel Content" paragraph type (dmf_content_modifier).
 * This paragraph type renders content from Anyrel's ContentModifierHandler
 * rather than displaying field values.
 *
 * Unlike page/element content modifiers (which personalize existing content),
 * plugin content modifiers generate their own markup entirely from Anyrel.
 */
function dmf_collector_core_paragraph_view(array &$build, ParagraphInterface $entity, EntityViewDisplayInterface $display, string $view_mode): void {
  // Only handle our specific paragraph type.
  if ($entity->bundle() !== 'dmf_content_modifier') {
    return;
  }

  // Get the configuration from the field.
  if (!$entity->hasField('field_dmf_plugin_config')) {
    return;
  }

  $configurationDocument = $entity->get('field_dmf_plugin_config')->value ?? '';
  if (empty($configurationDocument)) {
    return;
  }

  try {
    /** @var RegistryCollectionInterface $registryCollection */
    $registryCollection = \Drupal::service('dmf_core.registry_collection');

    /** @var CollectorRegistryInterface $collectorRegistry */
    $collectorRegistry = $registryCollection->getRegistryByClass(CollectorRegistryInterface::class);

    $handler = $collectorRegistry->getContentModifierHandler();

    // Generate unique ID for this paragraph instance.
    $id = 'dmf-p-' . $entity->id();

    // Render the content modifier.
    // asList = false because plugin content modifiers have a single modifier.
    $html = $handler->renderFromConfigurationDocument(
      $configurationDocument,
      false, // asList
      $id
    );

    // Replace the field output with the rendered content.
    // The hidden formatter already produces no output, but we explicitly
    // set the content to ensure only our rendered HTML appears.
    $build['field_dmf_plugin_config'] = [
      '#markup' => $html,
      '#weight' => 0,
    ];

    // Ensure the ID attribute is set on the paragraph wrapper.
    if (!isset($build['#attributes'])) {
      $build['#attributes'] = [];
    }
    $build['#attributes']['id'] = $id;

  } catch (\Exception $e) {
    \Drupal::logger('dmf_collector_core')->error(
      'Error rendering plugin content modifier for paragraph @id: @message',
      ['@id' => $entity->id(), '@message' => $e->getMessage()]
    );

    // Show error message in development mode.
    $build['field_dmf_plugin_config'] = [
      '#markup' => '<div class="dmf-error">Error rendering content modifier.</div>',
      '#weight' => 0,
    ];
  }
}

/**
 * Implements hook_block_view_alter().
 *
 * Handles element content modifiers for block_content blocks rendered via
 * Block plugins (Block Layout or Block Field). This sets the ID on the
 * Block plugin wrapper, which includes the display title.
 *
 * For block_content rendered directly (e.g., drupal_entity() in Twig),
 * the entity pre-render callback handles it instead.
 *
 * @see \Drupal\dmf_collector_core\Render\ContentModifierPreRender
 */
function dmf_collector_core_block_view_alter(array &$build, BlockPluginInterface $block): void {
  // Only handle block_content blocks.
  if (!$block instanceof BlockContentBlock) {
    return;
  }

  // Get the block_content entity from the block plugin.
  $uuid = $block->getDerivativeId();
  $entities = \Drupal::entityTypeManager()
    ->getStorage('block_content')
    ->loadByProperties(['uuid' => $uuid]);
  $blockContent = reset($entities);

  if (!$blockContent) {
    return;
  }

  // Delegate to the service which handles field checking, settings registration,
  // and wrapper application. It also sets the drupal_static flag to prevent
  // double-processing in the entity pre-render callback.
  \Drupal::service('dmf_collector_core.content_modifier_pre_render')
    ->processBlockElementModifier($build, $blockContent);
}
